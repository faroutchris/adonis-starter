import { HttpContext } from '@adonisjs/core/http'
import TurboStream from '../turbo_stream.js'
import { ErrorExtractor } from './error_extractor.js'
import { FieldMapper } from './field_mapper.js'
import {
  ErrorTransform,
  FieldMapper as FieldMapperType,
  ValidationError,
  ValidationManagerConfig,
} from './types.js'
/**
 * ValidationManager class that handles all server validation logic
 *
 * This class encapsulates validation error detection, field mapping, and Turbo Stream generation
 * to provide a clean API for handling server validation errors.
 */
export class ValidationManager {
  /**
   * Custom field mapping function
   * @private
   */
  private customFieldMapper: FieldMapperType | null = null

  /**
   * Custom error transformation function
   * @private
   */
  private errorTransform: ErrorTransform | null = null

  /**
   * Manual field errors added via addFieldError method
   * @private
   */
  private manualFieldErrors: ValidationError[] = []

  /**
   * Configuration options for ValidationManager behavior
   * @private
   */
  private config: ValidationManagerConfig = {
    fallbackBehavior: 'flash',
  }

  /**
   * Create a new ValidationManager instance
   *
   * @param ctx HttpContext instance
   * @param turboStream TurboStream instance
   * @param errorExtractor ErrorExtractor instance
   * @param fieldMapper FieldMapper instance
   */
  constructor(
    private ctx: HttpContext,
    private turboStream: TurboStream,
    private errorExtractor: ErrorExtractor,
    private fieldMapper: FieldMapper
  ) {}

  /**
   * Check if an error is a validation error
   *
   * @param error The error to check
   * @returns boolean indicating if the error is a validation error
   */
  isValidationError(error: unknown): boolean {
    return this.errorExtractor.isVineJSError(error) || this.manualFieldErrors.length > 0
  }

  /**
   * Check if the current request supports Turbo Stream responses
   *
   * @returns boolean indicating if Turbo Stream is enabled for this request
   */
  isTurboEnabled(): boolean {
    const isTurboStream = this.turboStream.isTurboStream()
    const isTurboFrame = this.ctx.turboFrame.isTurboFrame()
    const hasTurboHeader = !!this.ctx.request.header('X-Turbo')

    return isTurboStream || isTurboFrame || hasTurboHeader
  }

  /**
   * Handle a validation error and generate an appropriate response
   *
   * This method orchestrates the entire validation error handling flow:
   * 1. Extract validation errors from the error object
   * 2. Map field names to input IDs
   * 3. Generate Turbo Stream response with invoke actions
   *
   * @param error The validation error to handle
   * @returns Promise resolving to a string containing the Turbo Stream response
   */
  async handleValidationError(error: unknown): Promise<string> {
    // Set the appropriate status code for validation errors
    this.ctx.response.status(422)

    // Extract validation errors from the error object
    let validationErrors = this.errorExtractor.extractValidationErrors(error)

    // Add any manual field errors
    if (this.manualFieldErrors.length > 0) {
      validationErrors = [...validationErrors, ...this.manualFieldErrors]
    }

    // Apply error transformation if configured
    if (this.errorTransform) {
      validationErrors = validationErrors.map(this.errorTransform)
    }

    // Generate invoke actions for each validation error targeting specific form inputs
    for (const validationError of validationErrors) {
      // Map field name to input ID using either custom mapper or default mapper
      const fieldName = validationError.field
      const inputId = this.customFieldMapper
        ? this.customFieldMapper(fieldName)
        : this.fieldMapper.mapFieldToInputId(fieldName)

      // Add invoke action to the Turbo Stream
      this.turboStream.invoke(`#${inputId}`, 'serverError', [
        validationError.field,
        validationError.message,
      ])
    }

    // If no validation errors were found, add a generic error message
    if (validationErrors.length === 0) {
      this.turboStream.flash('error', 'Validation failed. Please check your input.')
    }

    // Render and return the Turbo Stream response
    return this.turboStream.render()
  }

  /**
   * Add a manual field error
   *
   * This method allows adding custom validation errors for specific fields
   * that aren't generated by the validation library.
   *
   * @param fieldName The field name to add an error for
   * @param message The error message
   * @returns This ValidationManager instance for method chaining
   */
  addFieldError(fieldName: string, message: string): ValidationManager {
    this.manualFieldErrors.push({
      field: fieldName,
      message: message,
    })
    return this
  }

  /**
   * Set a custom field mapping function
   *
   * This method allows customizing how field names are mapped to input IDs.
   *
   * @param mapper The custom field mapper function
   * @returns This ValidationManager instance for method chaining
   */
  withCustomMapping(mapper: FieldMapperType): ValidationManager {
    this.customFieldMapper = mapper
    return this
  }

  /**
   * Set a custom error transformation function
   *
   * This method allows transforming validation errors before they are processed.
   *
   * @param transform The error transformation function
   * @returns This ValidationManager instance for method chaining
   */
  withErrorTransform(transform: ErrorTransform): ValidationManager {
    this.errorTransform = transform
    return this
  }

  /**
   * Set configuration options for the ValidationManager
   *
   * @param config The configuration options
   * @returns This ValidationManager instance for method chaining
   */
  configure(config: Partial<ValidationManagerConfig>): ValidationManager {
    this.config = { ...this.config, ...config }
    return this
  }

  /**
   * Clear all manual field errors
   *
   * @returns This ValidationManager instance for method chaining
   */
  clearFieldErrors(): ValidationManager {
    this.manualFieldErrors = []
    return this
  }
}
